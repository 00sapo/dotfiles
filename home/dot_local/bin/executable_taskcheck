#!/bin/env python3
"""
This script checks if tasks can be completed on time, considering estimated time and working hours.

CONFIGURATION:
1. Create a TOML file at ~/.config/task/time_maps.toml with the following format:
```toml
[time_maps]
[time_maps.work]
monday = 8
tuesday = 8
wednesday = 8
thursday = 8
friday = 8
saturday = 0
sunday = 0

[time_maps.extra]
monday = 0
tuesday = 1
wednesday = 0
thursday = 1
friday = 0
saturday = 1
sunday = 3
```

2. Create a TOML file at ~/.local/share/task/exceptions.toml with the following format:
```toml
[exceptions]
2021-01-01 = 0
2021-01-02 = 3
2021-12-25 = 0
```

3. Add the taskwarrior config
```
uda.time_map.type = string
uda.time_map.label = Time Map
uda.estimated.type = duration
uda.estimated.label = Estimated Time
uda.completion_date.type = date
uda.completion_date.label = Expected Completion Date
recurrence.confirmation=no
```

OPTIONS:
-v, --verbose: increase output verbosity
"""

import subprocess
import tomllib
import json
from datetime import datetime, timedelta
from pathlib import Path
import argparse

config_dir = Path.home() / ".config/task"
data_dir = Path.home() / ".local/share/task"

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument(
    "-v", "--verbose", action="store_true", help="increase output verbosity"
)

args = arg_parser.parse_args()

# Taskwarrior status to avoid
AVOID_STATUS = ["completed", "deleted", "recurring"]

long_range_time_map = {}


# Load working hours and exceptions from TOML file
def load_config():
    with open(config_dir / "taskcheck.toml", "rb") as f:
        config = tomllib.load(f)
    with open(data_dir / "exceptions.toml", "rb") as f:
        exceptions = tomllib.load(f)
    return config, exceptions["exceptions"]


# Get tasks from Taskwarrior and sort by urgency
def get_tasks():
    result = subprocess.run(["task", "export"], capture_output=True, text=True)
    tasks = json.loads(result.stdout)
    return sorted(
        (task for task in tasks if "estimated" in task),
        key=lambda t: -t.get("urgency", 0),
    )


# Calculate available working hours for a given date, considering exceptions
def get_available_hours(time_map, date, exceptions):
    date_str = date.isoformat()
    if date_str in exceptions:
        return exceptions[date_str]  # Use exception hours if available
    day_of_week = date.strftime("%A").lower()
    return time_map.get(day_of_week, 0)


def convert_to_hours(duration_str):
    # string format is P#DT#H
    # with D and H optional
    duration_str = duration_str[1:]  # Remove leading "P"
    days, hours = 0, 0
    if "D" in duration_str:
        days, duration_str = duration_str.split("D")
        days = int(days)
    if "H" in duration_str:
        hours = int(duration_str.split("T")[1].split("H")[0])
        return days * 24 + hours


def get_long_range_time_map(time_maps, time_map_names, days_ahead, exceptions):
    key = ",".join(time_map_names)
    if key in long_range_time_map:
        task_time_map = long_range_time_map[key]
    else:
        if args.verbose:
            print(f"Calculating long range time map for {key}")
        task_time_map = []
        for d in range(days_ahead):
            date = datetime.today().date() + timedelta(days=d + 1)
            daily_hours = 0
            for time_map_name in time_map_names:
                if time_map_name not in time_maps:
                    raise ValueError(f"Time map '{time_map_name}' does not exist.")
                time_map = time_maps[time_map_name]
                daily_hours += get_available_hours(time_map, date, exceptions)
            task_time_map.append(daily_hours)
        long_range_time_map[key] = task_time_map

    return task_time_map


def _schedule_task_on_d(
    _starting,
    d,
    end_date,
    start_date,
    task,
    task_remaining_hours,
    task_time_map,
    today,
    used_hours,
    wait,
):
    # we can schedule task on this day
    employable_hours = task_time_map[d] - used_hours[d]
    current_date = today + timedelta(days=d + 1)
    if wait and current_date < wait:
        if args.verbose:
            print(f"Skipping date {current_date} because of wait date {wait}")
        return start_date, end_date, task_remaining_hours, _starting

    if _starting:
        if args.verbose:
            print(
                f"Starting task {task['id']} ('{task['description']}') on {current_date}"
            )
        _starting = False
        start_date = current_date

    if task_remaining_hours <= employable_hours:
        # consume all the remaining task's hours
        used_hours[d] += task_remaining_hours
        task_remaining_hours = 0
        end_date = current_date
        if args.verbose:
            print(
                f"Task {task['id']} ('{task['description']}') can be completed on {current_date}"
            )
            print(f"Used hours on {current_date}: {used_hours[d]}")
    else:
        # consume all the available hours on this task
        task_remaining_hours -= employable_hours
        used_hours[d] += employable_hours
        if args.verbose:
            print(
                f"Working for {employable_hours} hours on task {task['id']}  on {current_date}"
            )
    return start_date, end_date, task_remaining_hours, _starting


def _mark_end_date(config, due_date, end_date, i, start_date, task, todo):
    todo[i] = False

    if config["scheduler"]["use_start_end_fields"]:
        start_end_fields = [
            f"start:{start_date}",
            f"end:{end_date}",
        ]
    else:
        start_end_fields = []

    subprocess.run(
        [
            "task",
            str(task["id"]),
            "modify",
            f"completion_date:{end_date}",
            *start_end_fields,
        ],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    if due_date is not None and end_date > due_date:
        # print in bold red using ANSI escape codes
        print(
            f"\033[1;31mTask {task['id']} ({task['description']}') may not be completed on time\033[0m"
        )


# Check if tasks can be completed on time sequentially
def check_tasks_sequentially(tasks, config, exceptions):
    time_maps = config["time_maps"]
    today = datetime.today().date()
    todo = [True if t["status"] not in AVOID_STATUS else False for t in tasks]
    used_hours = [0] * config["scheduler"]["days_ahead"]

    while any(todo):
        for i, task in enumerate(tasks):
            if not todo[i]:
                # skipping tasks already completed
                continue

            due_date = (
                datetime.strptime(task["due"], "%Y%m%dT%H%M%SZ").date()
                if "due" in task
                else None
            )
            wait_date = (
                datetime.strptime(task["wait"], "%Y%m%dT%H%M%SZ").date()
                if "wait" in task
                else None
            )
            estimated_hours = (
                convert_to_hours(task["estimated"]) if "estimated" in task else None
            )  # Remove trailing "PT" and "H"
            time_map_names = (
                task.get("time_map").split(",") if "time_map" in task else None
            )
            if estimated_hours is None or time_map_names is None:
                todo[i] = False
                if args.verbose:
                    print(
                        f"Task {task['id']} ('{task['description']}') has no estimated time or time map: {estimated_hours}, {time_map_names}"
                    )
                continue
            if args.verbose:
                print(
                    f"Checking task {task['id']} ('{task['description']}') with estimated hours: {estimated_hours} and wait date: {wait_date}"
                )

            task_remaining_hours = estimated_hours
            task_time_map = get_long_range_time_map(
                time_maps,
                time_map_names,
                config["scheduler"]["days_ahead"],
                exceptions,
            )

            # Simulate work day-by-day until task is complete or past due
            _starting = True
            start_date = end_date = None
            for d in range(len(task_time_map)):
                if task_time_map[d] > used_hours[d]:
                    (start_date, end_date, task_remaining_hours, _starting) = (
                        _schedule_task_on_d(
                            _starting,
                            d,
                            end_date,
                            start_date,
                            task,
                            task_remaining_hours,
                            task_time_map,
                            today,
                            used_hours,
                            wait_date,
                        )
                    )

                if args.verbose:
                    print(
                        f"Task {task['id']} ('{task['description']}') remaining hours: {task_remaining_hours} - end date: {end_date} - todo: {todo[i]}"
                    )

                if end_date is not None:
                    _mark_end_date(
                        config, due_date, end_date, i, start_date, task, todo
                    )
                    break


# Load data and check tasks
config, exceptions = load_config()
tasks = get_tasks()
check_tasks_sequentially(tasks, config, exceptions)
